\chapter{Implementation}

% organise by features of app/api or by stages?

\section{Overview}

Since the back-end API and front-end mobile app are so tightly connected, implementing them linearly would not be logical as errors between the app and server will not be detected as quickly and requirements of features may change over time. I therefore implemented the two in parallel, normally a feature at a time, so that a working implementation for each subsequent feature was produced at the end of each iteration.

This section splits the implementation into the two sections, API and mobile app, with each discussing the features implemented chronologically.

\section{API}

\subsection{Endpoint Routing}

To set up endpoints on the API to respond to client requests, the popular Express web framework ***ref*** was used. Express's router object determines how the API handles a request to a certain URI with a specific HTTP method.

The main file loaded when a request is made, \texttt{app.js}, specifies the main endpoint for the API and links this endpoint to an Express router. This router specifies the path for each of the main API routes, following the design from Figure \ref{fig:api-routes} in the previous section. Each path contains a router that matches each of the endpoints it serves as well as a controller containing functions, known as middleware functions, which are executed when a router endpoint is matched from a request. An example of how a request to login a user is routed through the API is shown in Figure ***.

\subsection{Authentication}

The bulk of the authentication system for the project needed to be implemented in the back-end. Passport ***ref*** is a popular library that provides authentication middleware for Node.js. It supports multiple types of authentication -- each of which is implemented as a \textit{strategy}. Based on the request, the middleware can then call \verb|passport.authenticate()| passing the desired authentication strategy as a parameter.

For this project, both basic (local) and JWT authentication strategies needed to be implemented. The local strategy function is called when a \verb|POST /auth/login/| request is received. This function first checks whether a user with the given username exists in the database. If a user does exist, the password given is compared to the password stored in the database for that user. Passwords are hashed and salted before they are inserted in the database using the bcrypt library ***ref***, which also provides a function to compare a plaintext and hashed password used in the local authentication strategy. Given that the passwords match and the login is successful, a JWT is signed using a private key and the payload as the authenticated user object. This JWT is then returned to the client in the HTTP response message.

On the client-side, if a successful response is received from a login request then a singleton app-wide User object is created, which is then saved to the iOS keychain -- a secure persistent storage location in the operating system. Each time the mobile app is launched, the keychain is checked to see if a User object is stored and therefore the user is logged in. If an object is found, the main screen of the app is shown allowing the user to track walks, otherwise the initial authentication screen is displayed.

The documentation for the API specifies which requests require the user to be authenticated using JSON web tokens. The function to implement the JWT authentication strategy in the API looks for the token in the \textit{Authorization} header of the request in the form of \texttt{JWT \textit{token}}. To check whether the JWT is valid, the user's ID is extracted from the token and searched for in the database. The Router for the back-end API in the mobile app contains a boolean variable \verb|requiresJWTAuth| to specify which enumeration cases, each representing an endpoint, requires authentication. When this variable is true, the JWT is added in the header when constructing the request as described above.

Server-side validation checks can then be performed, depending on the request, to determine if the user has permission to perform the requested operation. For example, users should only be able to delete walks that they have tracked and not be able to delete any other users' walks. Therefore when a \verb|DELETE /walks/:walkID| request is sent, the walk -- referenced by its ID in the \textit{walkID} parameter -- is checked to see that it has been tracked by the user obtained through the JWT before the walk is deleted, otherwise a \textbf{401 Unauthorized} error is returned.

\subsection{Querying Database}



% mention mongoose populate

\subsection{Storing Images on a Server} \label{implementation:storing-images}

Having chosen to use the direct upload method described in Section \ref{subsection:file-storage-methods}, I outlines the steps that needed to be followed when uploading a file:

\begin{enumerate}[label=\textbf{Step \arabic*}]
  \item Request a pre-signed URL from the API to upload a file using the AWS SDK, giving the client the necessary permissions to upload at that location.
  \item Upload the file directly from the client to the URL.
  \item Store a reference to the URL where the file is stored either locally or in the back-end so that it can be accessed in the future.
\end{enumerate}

Even though the only current use for the file upload capability in the app is to store the thumbnail images of tracked walks, I wanted to make the code as re-usable as possible so that any feature implemented in the future could upload files with ease.

To implement \textbf{Step 1}, I created an endpoint in the API at \texttt{/walks/create/upload} to retrieve a signed URL from AWS S3. This accepted a GET request with no parameters that returned a URL that would expire in 60 seconds. The expiry time was used so that numerous empty URLs were not created by continuously sending a \texttt{GET /walks/create/upload} request, while still allowing enough time for the file to be uploaded by the client.

% alamofire or apimanager is not refd here
% move communication with API section to before this one?

Upon receiving the URL from the API, the mobile app then uploads the file to this location as in \textbf{Step 2}. Alamofire provides an \texttt{upload()} method along with its \texttt{request()} method that supports sending of larger amounts of data such as a file. The method accepts the file as a parameter in \texttt{Data} format, a datatype commonly used throughout iOS to store and transfer files or objects. Images can be converted to their Data representation using the \texttt{UIImageJPEGRepresentation()} function declared in Apple's UIKit, passing in a native \texttt{UIImage} object.

While the previous two steps have been fairly general to upload a file, \textbf{Step 3} of the method is what applies this code to the feature being implemented. In the case of this project, I needed to upload an image of a tracked walk and store a reference to the URL of that image in its own Walk document in the database. Once the image has been uploaded successfully, a Walk document is created via sending a \texttt{POST /walks/create} request to the API. The parameters of that request include the name of the walk, an array of coordinates and the URL of the image that was uploaded in the previous step.

\section{Mobile App}

\subsection{Communication with API}

% maybe put this near start of implementation as lots of sections reference it

To handle requests from the multiple APIs used within the mobile application, a singleton class \texttt{APIManager} was used that was accessible throughout the app to organise each API call. The main function of \texttt{APIManager} was to abstract the network requests through the HTTP networking library Alamofire ***ref*** -- a more elegant way to handle networking in comparison to Swift's default network tools, providing simple JSON encoding and serialisation as well as response validation.

Alamofire's Router design pattern allowed me to define a complete set of paths, methods and parameters needed for the endpoints of a particular API and hence construct a request with with any HTTP headers as appropriate. The Router was implemented as a protocol containing the necessary fields that needed to be overridden, and each API that needed to be documented in this way adopted this protocol and used an enumeration pattern to define each of the available endpoints for that API. The specific endpoint case for a given API router would then be passed as a parameter to Alamofire's \texttt{request()} method, which would construct and send the HTTP request as necessary.

Finally, an enumeration was created to represent the success or failure response received from the API. Enumeration cases in Swift can contain parameters and so I defined the success response to contain a JSON object that contained the response from the API, constructed in Alamofire's asynchronous request callback. Meanwhile, the failure case contained a Swift error object whose error code and description were populated from the information received from the API. Figure \ref{fig:api-communication} explains in more detail the path of method calls and how data is passed through callbacks when making a network request.

\begin{figure}[hbt]
  \centering
  \includegraphics[width=\textwidth]{api-communication}
  \caption{The path of method calls and callbacks used when making a network request within the mobile app, namely logging the user in. The top row of arrows represent method calls being made from the app whilst the bottom row of arrows represent the callbacks for each method once the network response is received.}
  \label{fig:api-communication}
\end{figure}


\subsection{Displaying Points of Interest on a Map}



\subsection{Gamification} \label{subsection:gamification}
% should this be in mobile app section?

The structure of the points system first needed to be implemented in the API, which the mobile app could then conform to. An object was defined as an enumeration in the back-end to represent the possible achievement types that could be gained from tracking a walk. Upon creating a walk via the \texttt{POST /walks/create} endpoint, the achievements parameter is checked against the list of valid achievement types. If one of the achievements is not valid, a \textbf{400 Bad Request} error is returned to the client.

% structure of achievements parameter

In the mobile app, a similar enumeration is defined to match the valid achievements listed in the back-end. When the user is saving a walk, the app checks whether there are achievements that the user should earn for the walk currently being saved. The achievements are sent to the server in the form of an array of dictionaries -- each element in the array a valid achievement with dictionary keys \textit{name} and \textit{value}, referring to the achievement type and number of points scored respectively. An example of a list of achievements sent in a request is as follows:

\begin{center}
  \verb|[{"name":"DAY_STREAK","value":4},{"name":"DISTANCE","value":100}]|
\end{center}


\subsection{Walk invitations}

\section{Challenges}