\chapter{Design}

\section{Overview}

The project can be split into two main sections -- the front-end mobile application and the back-end server to store data and communicate with the mobile app.

These two sections link together very closely and are both required to produce a working implementation. It is therefore extremely important to not only consider the design of the user interface but also more technical aspects, such as the way the user's data is stored in the database and how the API will communicate with the mobile app.

\section{Technology Choices}

The first part of the design of the project is to consider which technologies to use. The technologies that I chose stemmed either from the background research I conducted in the previous section or previous personal knowledge.

%\subsection{Mobile Operating System}

% move section in background to here?

\subsection{Version Control}

Version control is a crucial part of the development process with any project, especially this implementation-heavy project. It provides a full history of changes made to a codebase along with the ability to revert back to previous versions of code and work simultaneously on different features by creating branches. Git and GitHub are my chosen version control system and platform respectively due to past experience and familiarity.

Along with version control, errors or bugs in code must be detected quickly in order to not hinder the development process. To do this, the practice of continuous integration (CI) was used to integrate and test code frequently, making it easier to locate the origin of an error. There are many CI tools that can be used to automate code testing including Jenkins, Travis CI and BuddyBuild. I had no prior knowledge with any of these tools and so I researched the benefits and drawbacks of each service, which can be seen in Table \ref{table:ci-tools-options}.

\begin{table}[hbt]
  \centering
  \begin{tabular}{|m{1.5cm}||M{3cm}|M{3cm}|M{3cm}|M{3cm}|}
    \hline
     & \textbf{Jenkins} & \textbf{Travis CI} & \textbf{BuddyBuild} & \textbf{GitLab CI} \\
    \hline
    \hline
    Platform & Windows, macOS, Linux & Hosted & Hosted & Hosted on GitLab\\
    \hline
    Cost & Free & Free for students & \~\pounds55/month or free trial & Free for small individual projects\\
    \hline
    Main Feature & Plugins available for different languages & Linked well with GitHub & Designed for mobile development & Integrated with GitLab\\
    \hline
    Platform Specific & No & No & Yes & No\\
    \hline
  \end{tabular}
  \caption{Comparison of continuous integration tools}
  \label{table:ci-tools-options}
\end{table}




I concluded that Travis CI was most suitable option for me since it was hosted on GitHub and is not platform specific, meaning that I could use it to test both the mobile app and API even though they were written in different languages. Using an option like BuddyBuild could only be used for the mobile app, with another tool needed for the API.

\subsection{Third-party APIs}

As discussed in Section \ref{subsection:background-apis}, Apple Maps very well integrated with the Core Location framework in iOS, which makes it easy to deal with displaying the user's location on a map. It also provides convenient functions for coordinate conversions and calculating distances between two coordinates, which is useful for this project when trying to calculate the distance of a tracked walk.

For these reasons, I chose to use Apple Maps and their MapKit framework as the source of maps within the application. The one issue that I previously discussed with using this framework over Google Maps was the lack of detail in some areas of the maps. This factor was not deemed important enough to impact my decision and did not outweigh the benefits of the MapKit framework, as listed above.

% points of interest APIs

\subsection{Server Architecture} \label{subsection:server-architecture}

Before deciding what technologies to use for the server, such as which programming language to use, we must consider the type of architectural style to use. The aim of the API exposed by the server is to provide an abstraction between complex database queries and provide functionality that a client can use to query and update details. The Representational state transfer (REST) architectural principle fit the needs for this aim very well. Every component in a RESTful web service is a resource that can be accessed via the standard HTTP methods such as \textit{GET}, \textit{POST} and \textit{DELETE}. In comparison with other web services, such as the Simple Object Access Protocol (SOAP), RESTful services have much less overhead when sending data due to the extra XML header information sent when using SOAP.

With the architecture chosen, I assessed the options for the language to write the API in. There are a wide range of programming languages that could be used, and it came down to personal preference and how well it would suit the needs for this project. The popular options include PHP, Ruby, Python and Node.js ***ref*** -- the server-side environment run in Javascript. The only language in this list that I have experience in is Python, which would mean I would have to spend less time learning the language if I were to choose it. However, the advantage of Node.js for the purpose of this project is that objects in Javascript are built using Javascript Object Notation (JSON).

 RESTful web services support the use of multiple different data formats to serialise responses from the server, including HTML, XML and JSON. By choosing Node.js as the server language and JSON as the data type, I was able to easily parse data from HTTP requests and send responses in JSON despite not having any previous experience with Javascript.

\subsection{Database}

There are two types of database that could be used -- relational or non-relational. Relational databases are based upon relational algebra where data is stored in tables with queries to this data in the form of Structured Query Language (SQL). Each table in a relational database normally identifies a type of entity, and each instance of that entity is uniquely identifiable so that it can be referenced in other tables. SQL therefore supports the querying of this data across multiple tables using relational operators such as joining two tables. The most used services to model data in a relational database are MySQL and PostgreSQL, with the latter providing support for storing arrays -- which is useful for this project to store the coordinates of a walk.

The opposite of this data model is a non-relational, or NoSQL, database in which each data entry is stored as a JSON-like document. This approach has many advantages for this project, primarily the similarities in the way that the data is stored to JSON that is used in the API. As a result, data can be queried or inserted directly from a network request without any type conversions. NoSQL databases also have the benefit of faster query speeds and the ability to scale data horizontally, an important factor to consider when designing a database.

The leading service to use for managing document-based NoSQL databases is MongoDB. It was used in this project especially due to its similar use of Javascript and JSON, both of which are already employed in the Node.js API. I also used a popular object data modelling library, Mongoose ***ref***, which helped with validation and allowed me to define schemas for each of the type entities.

\subsection{API Deployment}

I opted to host my API on the platform as a service Heroku ***ref***, with the alternative being Imperial's Cloudstack service run by the Department of Computing. Having had little experience with either of these services, I learned that Heroku had certain features that gained itself an advantage over Cloudstack. Heroku is integrated with GitHub very well, my chosen version control platform, supporting automatic deployment when commits are made which can also be dependent on the results of continuous integration tests. Heroku also has a number of add-ons that can be used on your web applications, including mLab -- a cloud-hosted version of MongoDB that is essential for me following on from the choice of database discussed in the previous section. Conversely, Cloudstack does not support MongoDB outright and would therefore have taken more effort to set it up.

\subsection{File Storage}

An online file storage system was needed for the project to store thumbnail images of tracked walks, which is discussed in more detail in Section \ref{implentation:storing-images}. Due to the ephemeral nature of Heroku's file system, it is not possible to store permanent files there and therefore an alternative online file storage service must be used.

From the wide range of services available, there is one stand-out option that I chose to use -- Amazon's simple storage service known as AWS S3. Its free usage tier allows up to 5GB of data storage which would be plenty for the purposes of this project. It also provides an SDK for Javascript which was necessary in order to implement the storing and deletion of images from the API.

\section{App Design}

% design of app
% how screens are organised
% survey



\subsection{User Interface}




\subsection{Model-View-Controller Design Pattern}

% mvc
% tab-bar
% human interface guidelines

\section{API Design}

% REST model, specific endpoints, etc.

Given that the API dealt primarily with JSON because of its easy connectivity with Node.js and MongoDB, responses were returned in JSON. Each response contained a success boolean as one of the values in JSON, determining whether the request was successful or not. HTTP error codes were used to determine the nature of a response as well, but the success flag was useful for error checking within the API.

The following section discusses how the structure of the API is organised as well as how the data was split up in the database.

% add image of how api links to app?

\subsection{Database Models}

% types of models – user, walk, invite, etc.

The data that needed to be stored in the database was split into multiple tables, or collections as they are called in MongoDB, to organise the data effectively. The full UML diagram showing each table's fields and how they link together can be seen in Figure \ref{fig:db-models}. A description of each of the four main tables is as follows:

\begin{itemize}
  \item \textbf{User} stores information about a user, created when they register. It contains cumulative values for the user's score, how far they have walked and how many steps they have taken. It also stores a user's device token, which is used to send a notification to a user's phone when inviting someone to go on a walk.

  \item \textbf{Invite} contains details of an invite sent from one user to one or more other users. Each user in the list of invite recipients contains a boolean flag to indicate whether that user has accepted the invite.

  \item \textbf{Achievement} is a fairly basic collection that stores the type of achievement that was gained from tracking a walk as well as how many points were gained from that achievement. The gamification and achievement aspect of the project is discussed in more detail in Section \ref{subsection:gamification}.
 
  \item \textbf{Walk} stores the details and representation of a walk, given a list of coordinates. It contains a reference to which user(s) tracked the walk, along with what achievements were gained.
\end{itemize}

% add required fields
% write description about each one?

\begin{figure}[hbt]
  \centering
  \includegraphics[width=0.75\textwidth]{db-models}
  \caption{Diagram of the different database models used in the project. Arrows indicate where a table references another table}
  \label{fig:db-models}
\end{figure}

\subsection{Endpoint Structure}

The REST architectural style dictates that each resource in the web service uniquely identifies one resource. Based on this, I chose to create a number of endpoints that each provided access to a resource on the server. An endpoint is a reference to a uniform resource indicator (URI) that provides access to a resource. These endpoints were grouped into similar categories, where each category is known as a route, to provide clarity to the client. For example, all endpoints that update user information are grouped under the \textit{/users/} route, with specific user endpoints a subpath of this route. The diagram representation of all of the routes used for the API is shown in Figure \ref{fig:api-routes}.

\begin{figure}[hbt]
  \centering
  \includegraphics[width=0.7\textwidth]{api-routes}
  \caption{Diagram of each of the routes designed for the API. Each route contains a description of what endpoints exist within that route.}
  \label{fig:api-routes}
\end{figure}

Each endpoint in the API followed the CRUD functions -- standing for Create, Read, Update and Delete. These functions are used to define what operation is being performed when changing data in the database. These functions map to HTTP methods very well, which can then be used in each endpoint to clearly state what operation is used. For example, an endpoint that deletes certain data from the database should adopt the \textit{Delete} function of CRUD and therefore also use the DELETE HTTP method.
 



